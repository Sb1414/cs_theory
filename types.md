[Вопросы](README.md)

# Типы данных и переменные

+ [Типы данных](#типы-данных)
+ [Разница между readonly и const полями](#разница-между-readonly-и-const-полями)
+ [Какие примитивные типы знаете ?](#какие-примитивные-типы-знаете-)
+ [Что такое Nullable-тип ?](#что-такое-nullable-тип-)
+ [Что такое тип значения, а что такое тип ссылки?](#что-такое-тип-значения-а-что-такое-тип-ссылки-)
+ [Что из этого class, а что struct ? В каком участке памяти они хранятся ?](#что-из-этого-class-а-что-struct--в-каком-участке-памяти-они-хранятся-)
+ [Чем отличаются value от reference type ? String - это reference или value ?](#чем-отличаются-value-от-reference-type--string---это-reference-или-value-)
+ [Куча это](#куча-это)
+ [В чем отличие между string builder и string ?](#в-чем-отличие-между-string-builder-и-string-)
+ [Что такое дженерики ? Какие проблемы они решают ?](#что-такое-дженерики--какие-проблемы-они-решают-)
+ [Что такое boxing / unboxing ?](#что-такое-boxing--unboxing-)
+ [Что такое сборка мусора ?](#что-такое-сборка-мусора-)
+ [Какие типы можно использовать в предложении foreach ?](#какие-типы-можно-использовать-в-предложении-foreach-)
+ [В чем различие между классом и структурой ?](#в-чем-различие-между-классом-и-структурой-)
+ [Что означает модификатор virtual ?](#что-означает-модификатор-virtual-)
+ [Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы ? Каким образом ?](#может-ли-класс-реализовать-два-интерфейса-у-которых-объявлены-одинаковые-методы--каким-образом-)
+ [Рефлексия (Reflection)](#рефлексия-reflection)


## Типы данных
Тип данных определяет внутреннее представление данных, множество значений, которые может принимать объект, а также допустимые действия, которые можно применять над объектом.

В языке программирования C# существует несколько типов данных, включая:

1. Целочисленные типы данных: int, long, short, byte и другие.

2. Вещественные типы данных: float, double, decimal.

3. Логический тип данных: bool, который может принимать только значения true или false.

4. Символьный тип данных: char, который используется для хранения одиночного символа.

5. Строковой тип данных: string, который используется для хранения наборов символов.

6. Массивы: тип данных, который позволяет хранить наборы однотипных элементов.


В языке C# есть следующие базовые типы данных:

- bool: хранит значение true или false (логические литералы). Представлен системным типом System.Boolean
- byte: хранит целое число от 0 до 255 и занимает 1 байт. Представлен системным типом System.Byte
- sbyte: хранит целое число от -128 до 127 и занимает 1 байт. Представлен системным типом System.SByte
- short: хранит целое число от -32768 до 32767 и занимает 2 байта. Представлен системным типом System.Int16
- ushort: хранит целое число от 0 до 65535 и занимает 2 байта. Представлен системным типом System.UInt16
- int: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта. Представлен системным типом System.Int32. Все целочисленные литералы по умолчанию представляют значения типа int:
- uint: хранит целое число от 0 до 4294967295 и занимает 4 байта. Представлен системным типом System.UInt32
- long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт. Представлен системным типом System.Int64
- ulong: хранит целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт. Представлен системным типом System.UInt64
- float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта. Представлен системным типом System.Single
- double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта. Представлен системным типом System.Double
- decimal: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*10-28 до ±7.9228*1028, может хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом System.Decimal
- char: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом System.Char. Этому типу соответствуют символьные литералы:
- string: хранит набор символов Unicode. Представлен системным типом System.String. Этому типу соответствуют строковые литералы.
- object: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом System.Object, который является базовым для всех других типов и классов .NET.

Однако мы можем использовать и модель неявной типизации:
```
var hello = "Hell to World";
var c = 20;
```
Эти переменные подобны обычным, однако они имеют некоторые ограничения:
- Во-первых, мы не можем сначала объявить неявно типизируемую переменную, а затем инициализировать:
```
// этот код работает
int a;
a = 20;
 
// этот код не работает
var c;
c = 20;
```
Во-вторых, мы не можем указать в качестве значения неявно типизируемой переменной null:
```
// этот код не работает
var c = null;
```
Так как значение null, то компилятор не сможет вывести тип данных.

## [Разница между readonly и const полями](https://dev-station.ru/categories/csharp/cheatsheet/csharp-base-cheatsheet#3390)
- readonly полям можно присваивать значения в двух местах: в месте их создания и в конструкторах. Для констант же значения можно присвоить только в месте их создания.
- поля readonly - это "особые" переменные, поскольку в отличные от обычных переменных их значения можно изменить только в определённых местах, но после компиляции они всё так же остаются переменными, в отличии от констант. Ведь при компиляции во все места кода где использовалась константа будет подставлено её значение, а в самом классе её уже не будет
- const— это переменная, значение которой известно во время компиляции и не может быть изменено во время выполнения. Она должна быть инициализирована при объявлении и не может быть изменена после её установки. Например:
```
const int x = 10;
x = 20; // Error: A constatnt value must be a compile-time constant
```
- readonly— это переменная, значение которой можно установить только во время инициализации или в конструкторе. Его можно изменить во время выполнения. Например:
```
public class MyClass
{
    //during initialization
    public readonly int x = 5;
    public readonly int y;
    public MyClass(int someValue)
    {
        //initialization in a constructor
        y = someValue;
    }

    public void MyMethod()
    {
        // Attempting to assign a new value to a readonly variable
        // will result in a compile-time error
        y = 20; // Error
    }
}
```

## Какие примитивные типы знаете ?
В C# существуют следующие примитивные типы данных:

1. Целочисленные типы:
   - byte
   - sbyte
   - short
   - ushort
   - int
   - uint
   - long
   - ulong

2. Типы с плавающей точкой:
   - float
   - double

3. Логический тип:
   - bool

4. Символьный тип:
   - char

5. Типы для работы с датой и временем:
   - DateTime
   - TimeSpan

## Что такое Nullable-тип ?
Nullable-тип в C# представляет собой тип-оболочку над обычным типом данных, который позволяет значению этого типа быть равным null. Например, если у вас есть переменная типа int, то она не может быть равна null. Однако, если вы используете Nullable-тип для int (int?), то вы можете присвоить этой переменной значение int или null.

Синтаксис для использования Nullable-типа int выглядит так:
```
int? nullableInt = 10; // присваиваем значение int
int? nullableInt2 = null; // присваиваем значение null
```

Это очень полезно, когда вам нужно работать с данными, которые могут быть пустыми или неопределенными.

## Что такое тип значения, а что такое тип ссылки ?
В C# типы данных делятся на 2 категории: типы значений (*value types*) и ссылочные типы (*reference types*).

- Тип значения содержит само значение, хранящееся в памяти. Когда переменной типа значения присваивается другая переменная или происходит передача в функцию, создается копия этого значения. 
    > Примеры типов значений в C# включают целочисленные типы (int, byte, long), типы с плавающей точкой (float, double), логический тип (bool), структуры (structs) и перечисления (enums).

- Ссылочный тип содержит ссылку на местоположение в памяти, где хранится фактическое значение. Переменные ссылочных типов содержат ссылку, а не само значение. Когда переменной ссылочного типа присваивается другая переменная или происходит передача в функцию, обе переменные будут указывать на одно и то же местоположение в памяти. 
    > Примеры ссылочных типов в C# включают классы (class), интерфейсы (interface), делегаты (delegate) и массивы (array).

## Что из этого class, а что struct ? В каком участке памяти они хранятся ?
> классы хранятся в куче, а структуры - в стеке.
- **Класс (class)** - это ссылочный тип данных. Объекты класса размещаются в управляемой куче (managed heap). При использовании класса в C#, когда вы создаете экземпляр класса с помощью конструктора, вы работаете с объектом, ссылка на который хранится в стеке, а сам объект хранится в управляемой куче.

- **Структура (struct)** - это тип значения. Он хранится в стеке, а не в куче. При использовании структуры, ее экземпляр хранится непосредственно в стеке или в других переменных за исключением ссылочных объектов. Это позволяет более быстро работать с данными, но имеет ограничения в размере и использовании структур.


## [Чем отличаются value от reference type ? String - это reference или value ?](https://dev-station.ru/categories/csharp/cheatsheet/csharp-base-cheatsheet#3382)
- Типы значений (value types) хранят свои данные напрямую в стеке, а их копии создаются при передаче в методы или присваивании другим переменным. Когда переменной типа значения присваивается другая переменная, она копируется, и каждая переменная хранит свою собственную копию значения. 
    > Примеры типов данных значений в C# включают целочисленные типы, типы со знаком (int, long, short), типы без знака (byte, ushort, uint), типы с плавающей запятой (float, double), структуры (structs) и перечисления (enums).

- Ссылочные типы (reference types), напротив, хранят ссылку (адрес) на местоположение в управляемой куче (managed heap), где хранится фактическое значение. Когда переменной ссылочного типа присваивается другая переменная или происходит передача в метод, обе переменные будут указывать на одно и то же местоположение в памяти. 
    > Примеры ссылочных типов данных в C# включают классы (class), строки (string), интерфейсы (interface), делегаты (delegate) и массивы (array).

Относительно строки (string) в C#, это ссылочный тип данных, так как строки хранятся в управляемой куче (managed heap). Когда вы работаете с переменными строкового типа, вы работаете с их ссылками, а не с фактическими данными, их значение не может быть изменено (строки - неизменяемые типы).

## Куча это
это область памяти, используемая для динамического выделения памяти для объектов во время выполнения программы.

это область памяти, в которой хранятся объекты классов (reference type), массивы и другие типы данных, созданные в процессе выполнения программы. Когда вы создаете новый объект, массив или другую структуру данных, выделение памяти для них происходит в управляемой куче.

в управляемой куче работает *механизм сборки мусора*, который автоматически освобождает память, занимаемую объектами, которые больше не используются, чтобы предотвратить утечку памяти и эффективно управлять ресурсами.

## В чем отличие между string builder и string ?
StringBuilder предназначен для работы с изменяемыми строками, тогда как тип string представляет неизменяемые строки.

1. Тип string:
   - Строки (string) в C# являются неизменяемыми (immutable) объектами. Это означает, что после создания строки ее значение не может быть изменено. Все операции над строками (например, конкатенация, замена символов и т. д.) фактически создают новые строки в памяти. Это может привести к созданию множества временных объектов в памяти, особенно при обработке больших объемов данных.

2. Класс StringBuilder:
   - В отличие от строк, StringBuilder представляет изменяемую (mutable) последовательность символов. Он предназначен для построения длинных строк и позволяет эффективно изменять, добавлять или удалять символы в строке без создания большого количества временных объектов в памяти. По сравнению со строками, класс StringBuilder более эффективен при выполнении множества операций изменения содержимого строки.

## Что такое дженерики ? Какие проблемы они решают ?
Дженерики решают ряд проблем, включая:
1. Универсальность - позволяют создавать общие алгоритмы и структуры данных, которые могут быть использованы с различными типами данных.
2. позволяют обрабатывать ошибки на этапе компиляции, а не на этапе выполнения, так как типы данных контролируются на этапе компиляции.
3. код, написанный с использованием дженериков, может быть более эффективным, так как избегается необходимость приведения типов и других операций во время выполнения.

Таким образом, дженерики позволяют улучшить переиспользование кода, упростить и ускорить разработку и повысить безопасность программы.

## [Что такое boxing / unboxing ?](https://dev-station.ru/categories/csharp/cheatsheet/csharp-base-cheatsheet#3380)
Boxing и unboxing - это процессы преобразования [значимых типов (типов значения) в ссылочные типы (типы ссылок)](#чем-отличаются-value-от-reference-type--string---это-reference-или-value-) и обратно.

Boxing - позволяет преобразовать размерный тип в ссылочный, а unboxing - обратный процесс.

При упаковке объекта размерного типа происходят следующие действия:

1. Выделяется память в управляемой [куче](#куча-это). Ее объем определяется длиной размерного типа. 
2. Совершается копирование полей размерного типа в память, которая была выделена в куче.
3. Возвращается адрес объекта. Этот адрес является ссылкой на объект; размерный тип превратился в ссылочный.

    ```
    int i = 13;
    object myObject = i; 	// boxing 
    i = (int)myObject;	// unboxing 
    ```


## [Что такое сборка мусора ?](https://dev-station.ru/categories/csharp/cheatsheet/csharp-base-cheatsheet#3381)
**Сборка мусора** – это низкоприоритетный процесс, который служит в качестве автоматического менеджера памяти, управляющего распределением и освобождением памяти для приложений.

Фазы сборки мусора:
- Маркировка (mark phase).
- Чистка (sweep phase).
- Сжатие (compact phase).


1. Каждый раз, когда создается новый объект, среда выполнения общего языка выделяет память для этого объекта из управляемой кучи. 
2. Пока в управляемой куче есть свободное пространство памяти, среда выполнения продолжает выделять место для новых объектов. 
3. Однако память не бесконечна, и как только приложение заполняет пространство, в дело вступает сборщик мусора (Garbage Collector), который освобождает часть памяти.

Когда сборщик мусора выполняет очистку, он проверяет объекты в управляемой куче, которые больше не используются приложением, и выполняет необходимые операции. Сборщик мусора останавливает все запущенные потоки, находит все объекты в куче, к которым не обращается основная программа, и удаляет их. Затем он собирает все объекты, оставшиеся в куче, чтобы освободить место, и корректирует все указатели на эти объекты в стеке и в куче.

Чтобы запустить сборку мусора в коде вручную, выполняем следующую команду:
`System.GC.Collect();`

## Какие типы можно использовать в предложении foreach ?
Массивы, коллекции. Классы в которых реализован интерфейс System.Collections.IEnumerable.

## В чем различие между классом и структурой ?
- классы  — это ссылочные типы (память выделяется из упр. кучи). 
- структуры и перечисления  - размерные типы. 

Например, структуры System.In132, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).

## Что означает модификатор virtual ?
При наследовании класса. Данный метод м.б. переопределен в производных классах с помощью ключевого слова override.

## Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы ? Каким образом ?
Да
```
public class GiuseppePizzaria : IWindow, IRestaurant 
{
   // Реализация метода GetMenu интерфейса IWindow.
   Object IWindow.GetMenu() { ... }
   // Реализация метода GetMenu интерфейса IRestaurant.
   Object IRestaurant.GetMenu() { ... }
}
```

## Рефлексия (Reflection)
Рефлексия представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения. То есть основная задача рефлексии - это исследование типов.

Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection. В нем мы можем выделить следующие основные классы:

Assembly: класс, представляющий сборку и позволяющий манипулировать этой сборкой

AssemblyName: класс, хранящий информацию о сборке

MemberInfo: базовый абстрактный класс, определяющий общий функционал для классов EventInfo, FieldInfo, MethodInfo и PropertyInfo

EventInfo: класс, хранящий информацию о событии

FieldInfo: хранит информацию об определенном поле типа

MethodInfo: хранит информацию об определенном методе

PropertyInfo: хранит информацию о свойстве

ConstructorInfo: класс, представляющий конструктор

Module: класс, позволяющий получить доступ к определенному модулю внутри сборки

ParameterInfo: класс, хранящий информацию о параметре метода