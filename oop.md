[Вопросы](README.md)

# ООП

+ [Что такое _ООП_?](#что-такое-ооп-)
+ [Основные принципы ООП](#основные-принципы-ооп)
+ [Разрешено ли множественное наследование в c#?](#разрешено-ли-множественное-наследование-в-c-)

## Что такое ООП ?
__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

+ объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
+ каждый объект является экземпляром определенного класса 
+ классы образуют иерархии. 

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. 

## Основные принципы ООП
C# — это объектно-ориентированный язык программирования. Четыре основных принципа объектно-ориентированного программирования следующие.

+ Инкапсуляция. Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций. Инкапсуляция в программировании является объединением данных и кода, работающего с этими данными, в большинстве случае это сводится к тому, чтобы не давать доступа к важным данным напрямую.

+ Наследование. Возможность создания новых абстракций на основе существующих. Пример: Игры и дополнения, Версии смартфона

+ Полиморфизм. Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций. Полиморфизм немного напоминает универсальный пульт дистанционного управления, который может адаптироваться для управления различными устройствами. В программировании это означает, что один интерфейс может использоваться для управления разными методами, давая разные результаты в зависимости от контекста. Пример: Музыкальный плеер (может воспроизводить разные аудиоформаты, такие как mp3, wav и flac. Для каждого формата требуется свой метод воспроизведения, однако, вместо создания методов Play, PlayMp3, PlayWav, PlayFlac, правильнее будет использовать общий метод Play)
```
public class MusicPlayer
{
    public virtual void Play()
    {
        Console.WriteLine("Воспроизводим аудио в стандартном формате...");
    }
}

public class Mp3Player : MusicPlayer
{
    public override void Play()
    {
        Console.WriteLine("Воспроизводим mp3...");
    }
}

public class WavPlayer : MusicPlayer
{
    public override void Play()
    {
        Console.WriteLine("Воспроизводим wav...");
    }
}

public class FlacPlayer : MusicPlayer
{
    public override void Play()
    {
        Console.WriteLine("Воспроизводим flac...");
    }
}
```


+ Абстракция. Набор общих характеристик. Абстракция похожа на использование умного устройства, не зная его сложной схемы. Например, чтобы переключить канал на телевизоре, мы просто нажимаем на кнопку на пульте, как кодируется пультом нажатие на кнопку, передается на телевизор и декодируется нам не важно. Важно чтобы канал переключился, а не тонкости радиотехники. Вот и в программировании абстракция означает предоставление основных функций без погружения в детали.
Пример: Погода (чтобы узнать прогноз погоды мы просто открываем приложение на телефоне и оно показывает нам погоду. Как оно собирает для этого данные, как их обрабатывает, все это скрыто от нас.)
```
public abstract class WeatherApp
{
    public void DisplayForecast()
    {
        Console.WriteLine("Показываем текущий прогноз погоды...");
    }

    // Абстрактный метод получения данных, различающийся для текущего способа связи
    public abstract void GetWeatherData();
}

public class WifiWeatherApp : WeatherApp
{
    public override void GetWeatherData()
    {
        Console.WriteLine("Запрашиваем данные по WiFi...");
    }
}

public class MobileWeatherApp : WeatherApp
{
    public override void GetWeatherData()
    {
        Console.WriteLine("Запрашиваем данные по мобильной сети...");
    }
}
```

## Разрешено ли множественное наследование в c# ?
В C# не разрешено множественное наследование классов, то есть класс не может явно наследовать более одного класса. Это было решено для упрощения языка и уменьшения сложности внутренней реализации и поддержки. Однако C# поддерживает множественное наследование интерфейсов.

Множественное наследование интерфейсов позволяет классу реализовывать несколько интерфейсов, что предоставляет гибкость в определении функциональности. Таким образом, хотя множественное наследование классов не разрешено в C#, множественное наследование интерфейсов остается возможным.

пример множественного наследования интерфейсов в C#:
```
Message hello = new Message("Hello World");
hello.Print();  // Hello World
 
interface IMessage
{
    string Text { get; set; }
}
interface IPrintable
{
    void Print();
}
class Message : IMessage, IPrintable
{
    public string Text { get; set; }
    public Message(string text) => Text = text;
    public void Print()=> Console.WriteLine(Text);
}
```
В данном случае определены два интерфейса. Интерфейс IMessage определяет свойство Text, которое представляет текст сообщения. А интерфейс IPrintable определяет метод Print.

Класс Message реализует оба интерфейса и затем применяется в программе.