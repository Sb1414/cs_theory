[Вопросы](README.md)

# Коллекции

+ [Какие знаете коллекции ? ](#какие-знаете-коллекции-)
+ [Что такое generics ?](#что-такое-generics-)
+ [Что такое GetHashCode ?](#что-такое-gethashcode-)
+ [Что такое Array, List, HashSet, Dictionary ? Приведите примеры использования этих структур данных. Какая сложность операций с ними (поиск, вставка, удаление) ?](#что-такое-array-list-hashset-dictionary--приведите-примеры-использования-этих-структур-данных-какая-сложность-операций-с-ними-поиск-вставка-удаление-)
+ [Разница между System.Array.CopyTo() и System.Array.Clone() ?](#разница-между-systemarraycopyto-и-systemarrayclone-)
+ [Что делает оператор yield ?](#что-делает-оператор-yield-)

## Какие знаете коллекции ? 
Большая часть классов коллекций содержится в пространстве имен ***System.Collections.Generic.***

- Массивы (arrays): упорядоченные наборы элементов одного типа.
- Списки (List), множества (Set), словари (Dictionary) и другие коллекции: предоставляют удобные структуры данных для хранения и обработки групп элементов.
- Структуры (struct): пользовательские типы данных, которые могут содержать поля и методы, похожие на классы, но передаются по значению.
- Пользовательские классы (class): определенные пользователем типы данных, которые могут содержать поля, свойства и методы.

## [Что такое generics ?](https://dev-station.ru/categories/csharp/cheatsheet/csharp-base-cheatsheet#3392)
**Generics** — это обобщенные типы. Они нужны для описания похожих, но отличающихся какими-то характеристиками типов. Мы описываем общую структуру, а конкретную уже определяет пользователь дженерика.

Generics - мощная фича, доступная во многих статически типизированных языках программирования. С их помощью можно писать код, который работает со множеством разных типов, делая упор на их общие особенности, при этом позволяя различаться в определённых деталях.

## [Что такое GetHashCode ?](https://dev-station.ru/categories/csharp/cheatsheet/csharp-base-cheatsheet#3393)
**GetHashCode** используется для ускорения сравнения двух объектов. То есть, если требуется узнать, одинаковы ли какие-то два объекта, то сначала сравниваются их хэш-коды. Если они различаются, то значит и объекты различны. Если же совпадают, то тогда начинается дорогостоящее "настоящее" сравнение через **Equals**.

**GetHashCode** не возвращает уникальный ключ/хеш объекта. Разные объекты, даже одного типа, могут возвращать одинаковое значение - и это будет корректно.

Соответственно, **GetHashCode** нельзя использовать для сравнения объектов (только как вспомогательную функцию).

**GetHashCode** нужен для быстрого поиска в хеш-таблицах. Такие объекты как **HashSet**<T> и **Dictionary<TKey, TValue>** используют в своей работе хеш-таблицы. Если объект используется в качестве ключа в хеш-таблице, то значение его **GetHashCode** указывает на позицию в хеш-таблице. При этом на одной позиции может быть несколько разных элементов (у которых одинаковый **GetHashCode**).

## Что такое Array, List, HashSet, Dictionary ? Приведите примеры использования этих структур данных. Какая сложность операций с ними (поиск, вставка, удаление) ?
Array (массив) - это структура данных, которая хранит элементы одного типа по порядку. Пример использования: int[] numbers = {1, 2, 3, 4, 5}; Сложность операций: вставка и удаление O(n), поиск O(1).

List (список) - это универсальная динамическая структура данных, которая может хранить элементы различных типов. Пример использования: List<int> numbers = new List<int>(){1, 2, 3, 4, 5}; Сложность операций: вставка O(1), удаление O(n), поиск O(n).

HashSet - это структура данных, которая хранит уникальные значения без учета порядка. Пример использования: HashSet<int> numbers = new HashSet<int>(){1, 2, 3, 4, 5}; Сложность операций: вставка и удаление O(1), поиск O(1).

Dictionary (словарь) - это структура данных, которая хранит пары ключ-значение. Пример использования: Dictionary<string, int> ages = new Dictionary<string, int>(){{"Alice", 25}, {"Bob", 30}}; Сложность операций: вставка, удаление и поиск O(1).

Сложность операций в контексте алгоритмической теории обозначается как O(1), O(n) и т. д., где O - это асимптотическая сложность, а число указывает количество операций в зависимости от количества элементов в структуре данных.

- O(1) означает, что операция выполняется за постоянное количество шагов, независимо от размера входных данных. Вставка занимает постоянное количество времени, независимо от размера списка.

- O(n) означает, что операция выполняется в зависимости от количества элементов во входных данных. Удаление и поиск занимают время, пропорциональное количеству элементов в спис

## Разница между System.Array.CopyTo() и System.Array.Clone() ?
1. System.Array.CopyTo():

    - Описание: используется для копирования элементов массива в другой массив, начиная с определенного индекса в целевом массиве.
    - Сигнатура: public void CopyTo(Array array, int index)
    - Поведение: Этот метод изменяет целевой массив, в который происходит копирование. Если целевой массив меньше по размеру, чем исходный массив, или если index не является допустимым индексом в целевом массиве, метод вызовет исключение.
    - Пример использования:
        ```
        int[] sourceArray = { 1, 2, 3, 4, 5 };
        int[] targetArray = new int[5];

        sourceArray.CopyTo(targetArray, 0);
        ```
2. System.Array.Clone():
    - Описание: используется для создания точной поверхностной копии массива.
    - Сигнатура: public object Clone()
    - Поведение: Этот метод создает новый массив, который имеет тот же тип и содержит те же элементы, что и оригинальный массив. Однако, если массив содержит объекты, это будет поверхностное копирование, и изменения в одном массиве будут видны в другом.
    - Пример использования:
        ```
        int[] originalArray = { 1, 2, 3, 4, 5 };
        int[] clonedArray = (int[])originalArray.Clone();
        Обратите внимание, что в случае использования Clone(), вам может потребоваться явное приведение типа, так как метод возвращает object
        ```

## Что делает оператор yield ? 
Оператор yield в C# используется для создания итераторов, которые позволяют эффективно перебирать элементы последовательности без необходимости загружать все элементы в память сразу. Он часто используется в контексте работы с коллекциями или другими последовательностями данных.

- yield return: Используется для возврата значения из метода и сохранения текущего состояния выполнения, чтобы в следующий раз, когда метод вызывается, он продолжался с точки, где он был остановлен.
- yield break: Используется для завершения итерации.

Оператор yield используется внутри методов, которые возвращают IEnumerable<T>, IEnumerator<T>, IEnumerable или IEnumerator. Эти методы называются методами-итераторами, и они позволяют вам перебирать элементы последовательности без необходимости создавать полную коллекцию в памяти.
```
public IEnumerable<int> GenerateNumbers()
{
    for (int i = 0; i < 5; i++)
    {
        yield return i; // Генерация итератором значения
    }
}
```
В этом примере GenerateNumbers является методом-итератором. Когда код вызывает этот метод, он не выполняется полностью сразу. Вместо этого он начинает выполняться, но при каждом возврате yield он приостанавливает выполнение и возвращает значение клиенту, который обращается к методу. Когда клиент снова запрашивает следующий элемент, выполнение метода продолжается с того места, где оно было приостановлено.
