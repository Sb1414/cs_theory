[Вопросы](README.md)

# Общие вопросы

+ [От какого класса неявно наследуются все классы в .NET ?](#от-какого-класса-неявно-наследуются-все-классы-в-net-)
+ [Что такое рекурсия ?](#что-такое-рекурсия-)
+ [Анонимные функции](#анонимные-функции)
+ [Что такое делегаты ?](#что-такое-делегаты-)
+ [Что такое лямбда-выражение ?](#что-такое-лямбда-выражение-)
+ [Что такое параллельное программирование (многопоточность) и его назначение ? Какие классы используются ?](#что-такое-параллельное-программирование-многопоточность-и-его-назначение--какие-классы-используются-)
+ [Что такое IIS ?](#что-такое-iis)
+ [Что такое LINQ ?](#что-такое-linq-)

## От какого класса неявно наследуются все классы в .NET ?
В .NET все классы неявно наследуются от базового класса System.Object.

В языке программирования C# и в рамках .NET Framework отсутствует явный базовый класс для всех классов, но все классы неявно наследуются от класса System.Object. В .NET Framework это основной базовый класс, от которого наследуются все типы данных, в том числе и пользовательские классы.

Таким образом, любой класс в C# неявно является производным от System.Object. Этот класс предоставляет базовые методы, такие как Equals, GetHashCode, ToString и др., которые можно переопределить в пользовательских классах.


## Что такое рекурсия ?
Рекурсивная функция представляет такую конструкцию, при которой функция вызывает саму себя.

Возьмем, к примеру, вычисление факториала, которое использует формулу n! = 1 * 2 * … * n. То есть по сути для нахождения факториала числа мы перемножаем все числа до этого числа. Например, факториал числа 4 равен 24 = 1 * 2 * 3 * 4, а факторил числа 5 равен 120 = 1 * 2 * 3 * 4 * 5.

Определим метод для нахождения факториала:
```
int Factorial(int n)
{
    if (n == 1) return 1;
 
    return n * Factorial(n - 1);
}
```

Рекурсивный метод отличается главным образом тем, что он содержит оператор, в котором этот метод вызывает самого себя. Рекурсия является эффективным механизмом управления программой.

## Что такое делегаты ?
делегаты (delegates) - это тип данных, который представляет ссылку на метод. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы. Они позволяют передавать методы как параметры другим методам, сохранять ссылки на методы в коллекциях и вызывать их асинхронно.

Делегаты в C# связаны с событиями и обратными вызовами (callbacks), что позволяет реализовать асинхронное программирование и обработку событий.


Для объявления делегата используется ключевое слово delegate, после которого идет возвращаемый тип, название и параметры. Например:
```
delegate void Message();
```

Делегат Message в качестве возвращаемого типа имеет тип void (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.

Рассмотрим применение этого делегата:

```
Message mes;            // 2. Создаем переменную делегата
mes = Hello;            // 3. Присваиваем этой переменной адрес метода
mes();                  // 4. Вызываем метод
 
void Hello() => Console.WriteLine("Hello METANIT.COM");
 
delegate void Message(); // 1. Объявляем делегат
```

Делегат может указывать на множество методов, которые имеют ту же сигнатуру и возвращаемые тип. Все методы в делегате попадают в специальный список - список вызова или invocation list. И при вызове делегата все методы из этого списка последовательно вызываются. И мы можем добавлять в этот список не один, а несколько методов. Для добавления методов в делегат применяется операция +=:
```
Message message = Hello;
message += HowAreYou;  // теперь message указывает на два метода
message();              // вызываются оба метода - Hello и HowAreYou
 
void Hello() => Console.WriteLine("Hello");
void HowAreYou() => Console.WriteLine("How are you?");
 
delegate void Message();
```

Делегаты можно объединять в другие делегаты. Например:
```
Message mes1 = Hello;
Message mes2 = HowAreYou;
Message mes3 = mes1 + mes2; // объединяем делегаты
mes3(); // вызываются все методы из mes1 и mes2
 
void Hello() => Console.WriteLine("Hello");
void HowAreYou() => Console.WriteLine("How are you?");
 
delegate void Message();
```

## Анонимные функции
Анонимная функция в контексте программирования - это функция, которая не имеет имени и обычно создается непосредственно в месте своего использования. В C# анонимные функции могут быть созданы с использованием лямбда-выражений или делегатов.

Анонимные функции позволяют создавать код более компактным и обычно используются в ситуациях, когда требуется передать небольшую логику как параметр в другой метод, такой как LINQ-запросы, обработчики событий, асинхронные операции и т. д.

## Что такое лямбда-выражение ?
Лямбда-выражение используется для создания [анонимной функции](#анонимные-функции). Используется оператор объявления лямбда-выражения `=>` для отделения списка параметров лямбда-выражения от исполняемого кода. 

Чтобы создать лямбда-выражение, необходимо указать входные параметры (если они есть) с левой стороны лямбда-оператора и блок выражений или операторов с другой стороны.

**Лямбда-выражение** с выражением с правой стороны оператора => называется выражением лямбда. Выражения-лямбды возвращают результат выражения и принимают следующую основную форму.
```
(input-parameters) => expression
```

**Лямбда-оператор** напоминает лямбда-выражение, за исключением того, что инструкции заключаются в фигурные скобки:

```
(input-parameters) => { <sequence-of-statements> }
```

Тело лямбды оператора может состоять из любого количества операторов; однако на практике обычно используется не более двух-трех.
```
Action<string> greet = name =>
{
    string greeting = $"Hello {name}!";
    Console.WriteLine(greeting);
};
greet("World");
// Output:
// Hello World!
```

Входные параметры лямбда-выражения заключаются в круглые скобки. Нулевое количество входных параметров задается пустыми скобками:

```
Action line = () => Console.WriteLine();
```

## Что такое параллельное программирование (многопоточность) и его назначение ? Какие классы используются ?
Во фреймворк .NET была добавлена библиотека параллельных задач TPL (Task Parallel Library), основной функционал которой располагается в пространстве имен **System.Threading.Tasks**. Данная библиотека упрощает работу с многопроцессорными, многоядерными системами. Кроме того, она упрощает работу по созданию новых потоков. Поэтому обычно рекомендуется использовать именно TPL и ее классы для создания многопоточных приложений, хотя стандартные средства и класс Thread по-прежнему находят широкое применение.

В библиотеке классов .NET задача представлена специальным классом - классом **Task**, который находится в пространстве имен **System.Threading.Tasks**. Данный класс описывает отдельную задачу, которая запускается асинхронно в одном из потоков из пула потоков. Хотя ее также можно запускать синхронно в текущем потоке.

Для определения и запуска задачи можно использовать различные способы.

- Первый способ создание объекта Task и вызов у него метода Start:
```
Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
```
В качестве параметра объект Task принимает делегат Action, то есть мы можем передать любое действие, которое соответствует данному делегату, например, лямбда-выражение, как в данном случае, или ссылку на какой-либо метод. То есть в данном случае при выполнении задачи на консоль будет выводиться строка "Hello Task!".

А метод Start() собственно запускает задачу.

- Второй способ заключается в использовании статического метода **Task.Factory.StartNew()**. Этот метод также в качестве параметра принимает делегат Action, который указывает, какое действие будет выполняться. При этом этот метод сразу же запускает задачу:
```
Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
```
В качестве результата метод возвращает запущенную задачу.

- Третий способ определения и запуска задач представляет использование статического метода **Task.Run()**:
```
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));
```
Метод Task.Run() также в качестве параметра может принимать делегат Action - выполняемое действие и возвращает объект Task.

## Что такое IIS
[Internet Information Services](https://www.dmosk.ru/terminus.php?object=iis) — программное обеспечение для развертывания веб-сервера. Входит в состав Windows.

Поддерживает работу по протоколам [HTTP](protocols.md#что-такое-http), [HTTPS](protocols.md#что-такое-https), [FTP](protocols.md#что-такое-ftp), [SMTP](protocols.md#что-такое-smtp), [POP3](protocols.md#что-такое-pop3).

IIS можно установить не только на Windows Server, но и на клиентскую версию операционной системы. 

## Что такое LINQ ?
LINQ, или Language-Integrated Query, представляет собой набор функций, представленных в C# 3.0, который позволяет вам запрашивать и обрабатывать данные в различных источниках данных, включая массивы, списки и базы данных, используя согласованный и выразительный синтаксис.

Основное преимущество: он позволяет писать выразительный и удобочитаемый код, который можно использовать для фильтрации, сортировки и преобразования данных без необходимости писать сложные циклы и условные операторы.

LINQ включает в себя различные операторы запросов, такие как Where, Select, Join, GroupBy, OrderBy и др., которые позволяют выполнять разнообразные запросы к данным. LINQ также поддерживает анонимные типы, делегаты, лямбда-выражения и анонимные функции, что делает его мощным инструментом для обработки данных в C#.
![пример](img/linq.png)</br>


## SOLID
Термин "SOLID" представляет собой акроним (позволяет создать короткое слово или аббревиатуру) для набора практик проектирования программного кода и построения гибкой и адаптивной программы.

Сам акроним образован по первым буквам названий SOLID-принципов:
- Single Responsibility Principle (Принцип единственной обязанности)
- Open/Closed Principle (Принцип открытости/закрытости)
- Liskov Substitution Principle (Принцип подстановки Лисков)
- Interface Segregation Principle (Принцип разделения интерфейсов)
- Dependency Inversion Principle (Принцип инверсии зависимостей)

> Принципы SOLID - это не паттерны, их нельзя назвать какими-то определенными догмами, которые надо обязательно применять при разработке, однако их использование позволит улучшить код программы, упростить возможные его изменения и поддержку.

1. Принцип единственной обязанности: Каждый компонент должен иметь одну и только одну причину для изменения. То есть класс должен быть ответственен лишь за одну конкретную часть функциональности. 


2. Принцип открытости/закрытости - программные сущности должны быть открыты для расширения, но закрыты для модификации. Это означает, что код должен поддаваться расширению без необходимости изменения исходного кода.

    > (например, есть общий метод у повора "готовка", и для каждого разного блюда готовка разная, поэтому можно создать интерфейс с этим методом, который далее для каждого отдельного блюда переопределяется) 

3. Принцип подстановки Лисков - создание иерархий наследования. 
    > (пример: класс фигура абстрактный -> квадрат -> прямоугольник)

4. Принцип разделения интерфейсов (Interface Segregation Principle, ISP) - множество узкоспециализированных интерфейсов лучше, чем один универсальный интерфейс. Это означает, что интерфейсы должны быть разделены так, чтобы клиенты видели только те методы, которые им действительно нужны. Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.
    > (пример: *интерфес* сообщение -> *интерфес* голосовое сообщение, email, текстовое -> *класс* голосовое сообщение, email, текстовое)

5. Принцип инверсии зависимостей (Dependency Inversion Principle, DIP) - модули верхнего уровня не должны зависеть от модулей нижнего уровня. Они должны зависеть от абстракций, а не от конкретных реализаций. Принцип служит для создания слабосвязанных сущностей, которые легко тестировать, модифицировать и обновлять.

