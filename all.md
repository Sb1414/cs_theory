[Вопросы](README.md)

# Общие вопросы

+ [От какого класса неявно наследуются все классы в .NET ?](#от-какого-класса-неявно-наследуются-все-классы-в-net)
+ [Что такое рекурсия ?](#что-такое-рекурсия)
+ [Что такое делегаты ?](#что-такое-делегаты)
+ [Что такое лямбда-выражение ?](#что-такое-лямбда-выражение)
+ [Что такое параллельное программирование (многопоточность) и его назначение ? Какие классы используются ?](#что-такое-параллельное-программирование-многопоточность-и-его-назначение--какие-классы-используются)
+ [Что такое IIS ?](#что-такое-iis)

## От какого класса неявно наследуются все классы в .NET ?
В .NET все классы неявно наследуются от базового класса System.Object.

В языке программирования C# и в рамках .NET Framework отсутствует явный базовый класс для всех классов, но все классы неявно наследуются от класса System.Object. В .NET Framework это основной базовый класс, от которого наследуются все типы данных, в том числе и пользовательские классы.

Таким образом, любой класс в C# неявно является производным от System.Object. Этот класс предоставляет базовые методы, такие как Equals, GetHashCode, ToString и др., которые можно переопределить в пользовательских классах.


## Что такое рекурсия ?
Рекурсивная функция представляет такую конструкцию, при которой функция вызывает саму себя.

Возьмем, к примеру, вычисление факториала, которое использует формулу n! = 1 * 2 * … * n. То есть по сути для нахождения факториала числа мы перемножаем все числа до этого числа. Например, факториал числа 4 равен 24 = 1 * 2 * 3 * 4, а факторил числа 5 равен 120 = 1 * 2 * 3 * 4 * 5.

Определим метод для нахождения факториала:
```
int Factorial(int n)
{
    if (n == 1) return 1;
 
    return n * Factorial(n - 1);
}
```

Рекурсивный метод отличается главным образом тем, что он содержит оператор, в котором этот метод вызывает самого себя. Рекурсия является эффективным механизмом управления программой.

## Что такое делегаты ?
Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.

Для объявления делегата используется ключевое слово delegate, после которого идет возвращаемый тип, название и параметры. Например:
```
delegate void Message();
```

Делегат Message в качестве возвращаемого типа имеет тип void (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.

Рассмотрим применение этого делегата:

```
Message mes;            // 2. Создаем переменную делегата
mes = Hello;            // 3. Присваиваем этой переменной адрес метода
mes();                  // 4. Вызываем метод
 
void Hello() => Console.WriteLine("Hello METANIT.COM");
 
delegate void Message(); // 1. Объявляем делегат
```

Делегат может указывать на множество методов, которые имеют ту же сигнатуру и возвращаемые тип. Все методы в делегате попадают в специальный список - список вызова или invocation list. И при вызове делегата все методы из этого списка последовательно вызываются. И мы можем добавлять в этот список не один, а несколько методов. Для добавления методов в делегат применяется операция +=:
```
Message message = Hello;
message += HowAreYou;  // теперь message указывает на два метода
message();              // вызываются оба метода - Hello и HowAreYou
 
void Hello() => Console.WriteLine("Hello");
void HowAreYou() => Console.WriteLine("How are you?");
 
delegate void Message();
```

Делегаты можно объединять в другие делегаты. Например:
```
Message mes1 = Hello;
Message mes2 = HowAreYou;
Message mes3 = mes1 + mes2; // объединяем делегаты
mes3(); // вызываются все методы из mes1 и mes2
 
void Hello() => Console.WriteLine("Hello");
void HowAreYou() => Console.WriteLine("How are you?");
 
delegate void Message();
```

## Что такое лямбда-выражение ?
Лямбда-выражение используется для создания анонимной функции. Используйте оператор объявления лямбда-выражения=> для отделения списка параметров лямбда-выражения от исполняемого кода. 

Чтобы создать лямбда-выражение, необходимо указать входные параметры (если они есть) с левой стороны лямбда-оператора и блок выражений или операторов с другой стороны.

**Лямбда-выражение** с выражением с правой стороны оператора => называется выражением лямбда. Выражения-лямбды возвращают результат выражения и принимают следующую основную форму.
```
(input-parameters) => expression
```

**Лямбда-оператор** напоминает лямбда-выражение, за исключением того, что инструкции заключаются в фигурные скобки:

```
(input-parameters) => { <sequence-of-statements> }
```

Тело лямбды оператора может состоять из любого количества операторов; однако на практике обычно используется не более двух-трех.
```
Action<string> greet = name =>
{
    string greeting = $"Hello {name}!";
    Console.WriteLine(greeting);
};
greet("World");
// Output:
// Hello World!
```

Входные параметры лямбда-выражения заключаются в круглые скобки. Нулевое количество входных параметров задается пустыми скобками:

```
Action line = () => Console.WriteLine();
```

## Что такое параллельное программирование (многопоточность) и его назначение ? Какие классы используются ?
Во фреймворк .NET была добавлена библиотека параллельных задач TPL (Task Parallel Library), основной функционал которой располагается в пространстве имен **System.Threading.Tasks**. Данная библиотека упрощает работу с многопроцессорными, многоядерными системами. Кроме того, она упрощает работу по созданию новых потоков. Поэтому обычно рекомендуется использовать именно TPL и ее классы для создания многопоточных приложений, хотя стандартные средства и класс Thread по-прежнему находят широкое применение.

В библиотеке классов .NET задача представлена специальным классом - классом **Task**, который находится в пространстве имен **System.Threading.Tasks**. Данный класс описывает отдельную задачу, которая запускается асинхронно в одном из потоков из пула потоков. Хотя ее также можно запускать синхронно в текущем потоке.

Для определения и запуска задачи можно использовать различные способы.

- Первый способ создание объекта Task и вызов у него метода Start:
```
Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
```
В качестве параметра объект Task принимает делегат Action, то есть мы можем передать любое действие, которое соответствует данному делегату, например, лямбда-выражение, как в данном случае, или ссылку на какой-либо метод. То есть в данном случае при выполнении задачи на консоль будет выводиться строка "Hello Task!".

А метод Start() собственно запускает задачу.

- Второй способ заключается в использовании статического метода **Task.Factory.StartNew()**. Этот метод также в качестве параметра принимает делегат Action, который указывает, какое действие будет выполняться. При этом этот метод сразу же запускает задачу:
```
Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
```
В качестве результата метод возвращает запущенную задачу.

- Третий способ определения и запуска задач представляет использование статического метода **Task.Run()**:
```
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));
```
Метод Task.Run() также в качестве параметра может принимать делегат Action - выполняемое действие и возвращает объект Task.

## Что такое IIS
[Internet Information Services](https://www.dmosk.ru/terminus.php?object=iis) — программное обеспечение для развертывания веб-сервера. Входит в состав Windows.

Поддерживает работу по протоколам [HTTP](protocols.md#что-такое-http), [HTTPS](protocols.md#что-такое-https), [FTP](protocols.md#что-такое-ftp), [SMTP](protocols.md#что-такое-smtp), [POP3](protocols.md#что-такое-pop3).

IIS можно установить не только на Windows Server, но и на клиентскую версию операционной системы. 